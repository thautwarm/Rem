Token tk
comments ::= '#[\w\W]*';
T        ::= R'\n+' + ;
symbol  ::=  R'[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff]{1}[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\d_]*';

refName Throw ['&']
        ::=  ['&'] symbol;

number  ::=  R'0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)';

string  ::=  R'"[\w\W]*"';

const   ::=  R'`True`|`False`|`None`';

arg     ::=    ['...']
                ('_'         |
                  refName    |
                  tupleArg   |
                  string
                  ('++'
                  string)+   |
                  const      |
                  number     );

iterMark
        ::= ',';
argMany Throw [',' T]
        ::=  arg [([T] ',' [T] arg)+  [T] [iterMark]];
tupleArg Throw ['(' ')']
        ::= '(' argMany ')';


unaryOp ::= '`not`' | '+' | '-';
suffix  ::= '?'   | '??';

lambdef Throw ['{', '}', '|', ',', T]
        ::= '{'
            ['|' [symbol (',' symbol)*] '|']
            [T]
            [statements [T]]
            '}';

atom  Throw ['++']
        ::=  refName | const | string ('++' string)* | number |
            '(' expr ')'|
             listCons | tupleCons | setCons | dictCons | compreh |
             lambdef;

trailer Throw ['[', ']']
        ::= '[' exprMany ']';

atomExpr Throw['!']
        ::= atom ['!' trailer*];

invExp  ::= atomExpr invTrailer*;
invTrailer Throw ['.']
        ::= '.' atomExpr;

factor ::= [unaryOp] invExp [suffix];

binExp ::= factor (
        ('+'    | '-'   | '*'   | '/' | '%'  |
         '++'   | '--'  | '**'  | '//'|
         '^'    | '&'   | '|'   | '>>'| '<<' |
         '^^'   | '&&'  | '||'  |
         '`and`'| '`or`'| '`in`'|
         '|>'   |
         '>'    | '<'   | '>='  | '<='|
         '=='   | '!='  |
         '<-')
        factor)*;

caseExp Throw ['`case`', '`end`', T]
        ::= '`case`' expr [T] asExp* [otherwiseExp] [T] '`end`';

asExp  Throw ['=>', T, '`as`']
        ::= '`as`' argMany
            [
              [T] '`when`' [T] expr
            ]
            [T]
            ['=>' [T] [statements]];

otherwiseExp Throw ['`otherwise`', T]
        ::= '`otherwise`' [T] [statements [T]];

testExpr ::= caseExp | binExp;

callExp ::= testExpr testExpr*;

where Throw ['`where`', T, '`end`']   ::= '`where`' [T] [statements [T]] '`end`';

expr    ::=  callExp thenTrailer* [where];

thenTrailer Throw ['`then`'] ::= '`then`' callExp;

statements Throw [T]
        ::= [label] statement ([T] statement)*;
statement
        ::= (expr | let | breakUntil) [';'];
let    Throw ['`let`' '=']
        ::= '`let`' symbol '=' expr;

exprMany Throw [',', T] ::= expr [([T] ',' [T] expr)+  [T] [',']];
unpack   Throw ['...']  ::= '...' expr;
exprCons Throw [',']    ::= exprMany (unpack [',' exprMany])* [','];

kv       Throw [':', T] ::= expr ':' expr;
kvMany   Throw [',', T] ::= kv [([T] ',' [T] kv)+  [T] [',']];
kvCons   Throw [',']    ::= kvMany (unpack [',' kvMany])* [','];


listCons  Throw ['[' ']']
        ::= '[' [exprCons] ']';
tupleCons  Throw ['(' ')']
        ::= '(' [exprCons] ')';
setCons  Throw ['%' '{' '}']
        ::=  '%' '{' [exprCons] '}';
dictCons  Throw ['%' '{' '}']
        ::=  '%' '{' [kvCons] '}';

compreh  Throw['`from`' '`yield`']  ::=  '`from`' exprMany '`yield`' lambdef;

label Throw ['@']
           ::= '@' symbol;

breakUntil Throw ['`break-until`']
           ::= '`break-until`' symbol;

file Throw [T] ::= [T] [statements [T]];






