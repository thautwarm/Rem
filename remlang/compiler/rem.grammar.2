Token tk

singleImportExpr
        ::= '`import`' singleArgs ['`as`' symbol];
importAs
        ::= symbol ['as' symbol];
fromImportExpr
        ::= '`from`' singleArgs '`import`'  '(' importAs (',' importAs)* ')';
importExpr
        ::= singleImportExpr | fromImportExpr | remImport;
remImport Throw ['`import`' '`as`']
        ::= '`import`' string [ '`as`' symbol];


comments ::= '#[\w\W]*';
T        ::= R'\n+' + ;
symbol  ::=  R'[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff_]{1}[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\d_]*';

refName Throw ['&']
        ::=  ['&'] symbol;

number  ::=  R'0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)';

string  ::=  R'"[\w\W]*"';

const   ::=  R'`True`|`False`|`None`';

arg  Throw ['++']
        ::= ['...'] '_'      |
            ['...']  refName |
              tupleArg       |
              string         |
              const          |
              number         ;

iterMark
        ::= ',';
argMany Throw [',' T]
        ::=  arg [([T] ',' [T] arg)+  [T]] [iterMark];
tupleArg Throw ['(' ')', '[', ']']
        ::= '(' argMany ')'| '[' argMany ']';

singleArgs Throw [',']
        ::= symbol (',' symbol)*;

unaryOp ::= '`not`' | '+' | '-';
suffix  ::= '?'   | '??';

lambdef Throw ['{', '}', '|', ',', '`from`', '`let`', '`end`', T]
        ::= '{'
                ['|' [singleArgs] '|']
                [T]
                [statements [T]]
            '}'
            |
            '`from`' [T]
                [singleArgs [T]]
            '`let`' [T]
                [statements [T]]
            '`end`'
            ;


atom  Throw ['++']
        ::=  refName | const | string ('++' string)* | number |
            '(' expr ')'|
             listCons | tupleCons | setCons | dictCons | compreh |
             lambdef;

trailer Throw ['[' ']' '.']
        ::= '[' exprCons ']' | '.' symbol;

atomExpr Throw['!', T]
        ::= atom ['!' ([T] trailer)+];

invExp  ::= atomExpr invTrailer*;
invTrailer Throw ['.']
        ::= '.' atomExpr;

factor ::= [unaryOp] invExp [suffix];

binExp ::= factor (
        ('+'    | '-'   | '*'   | '/' | '%'  |
         '++'   | '--'  | '**'  | '//'|
         '^'    | '&'   | '|'   | '>>'| '<<' |
         '^^'   | '&&'  | '||'  |
         '`and`'| '`or`'| '`in`'| '`is`'     |
         '|>'   |
         '>'    | '<'   | '>='  | '<='|
         '=='   | '!='  |
         '<-')
        factor)*;

caseExp Throw ['`case`', '`end`', T]
        ::= '`case`' expr [T] asExp* [otherwiseExp] [T] '`end`';

asExp  Throw ['=>', T, '`as`', '`when`']
        ::= ['`as`' argMany]
            [
              [T] '`when`' [T] expr
            ]
            [T]
            ['=>' [T] [statements]];

otherwiseExp Throw ['`otherwise`', T]
        ::= '`otherwise`' [T] [statements [T]];

testExpr ::= caseExp | binExp;

callExp ::= testExpr testExpr*;

where Throw ['`where`', T, '`end`']   ::= '`where`' [T] [statements [T]] '`end`';

expr    ::=  callExp thenTrailer* [where];

thenTrailer Throw ['`then`'] ::= '`then`' callExp;

statements Throw [T]
        ::= statement ([T] statement)*;
statement
        ::= (label | let | expr | into | importExpr) [';'];
let    Throw ['=' '!']
        ::= ['`let`'] symbol ['!' trailer+] '=' expr;

exprMany Throw [',', T] ::= expr [([T] ',' [T] expr)+];
unpack   Throw ['...']  ::= '...' expr;
exprCons Throw [',']    ::= exprMany (',' unpack [',' exprMany])* [','];

kv       Throw [':', T] ::= expr ':' expr;
kvMany   Throw [',', T] ::= kv [([T] ',' [T] kv)+  [T]];
kvCons   Throw [',']    ::= kvMany (',' unpack [',' kvMany])* [','];


listCons  Throw ['[' ']']
        ::= '[' [exprCons] ']';
tupleCons  Throw ['(' ')']
        ::= '(' [exprCons] ')';
setCons  Throw ['%' '{' '}']
        ::=  '%' '{' [exprCons] '}';
dictCons  Throw ['%' '{' '}']
        ::=  '%' '{' [kvCons] '}';

compreh  Throw['`from`' '`yield`']
        ::=  '`from`' exprMany ['`not`'] '`yield`' lambdef;

label Throw ['@']
           ::= '@' symbol;

into Throw ['`into`']
           ::= '`into`' symbol;

file Throw [T] ::= [T] [statements [T]];






