Ignore [space comments]
refName  ::= ['&'] symbol;

newline  := R'\n+';
space    := R'\s+';
symbol   := R'[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff_]{1}[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\d_]*';

keyword  := 'then', 'when',   'and',    'or', 'not'
            'in',   'not',    'case',   'as'
            'end',  'where',  'from',   'yield'
            'into', 'let',    'True',   'False'
            'None', 'import', 'is';

string   := R'[A-Z]"([^\"]+|\\.)*?"|\'([^\\\']+|\\.)*?\'';
comments := R'(#.*)|(((/\*)+?[\w\W]+?(\*/)+))';
number   := R'0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)';


operator :=  '+',   '-',  '*',   '/',   '%'
             '++',  '--', '**',  '//'
             '^',   '&',  '|',   '>>',  '<<'
             '^^',  '&&', '||'
             '|>'
             '>',   '<', '>=', '<='
             '==',  '!='
             '<-';

T       ::= newline+;
importAs
        ::= symbol ['as' symbol];

fromImportExpr
        ::= 'from' singleArgs 'import'  '(' importAs (',' importAs)* ')';

importExpr
        ::= singleImportExpr | fromImportExpr | remImport;

singleImportExpr
        ::= 'import' singleArgs ['as' symbol];

remImport Throw ['import', 'as']
        ::= 'import' string [ 'as' symbol];


const   ::= 'True' | 'False' | 'None';



# lambda currently does not support argument destruction.
singleArgs Throw [',' T]
        ::= symbol ([T] ',' [T] symbol)*;

# for pattern matching
argMany Throw [',' T]
        ::=  arg [([T] ',' [T] arg)+  [T]] [iterMark];

iterMark::= ',';
arg  Throw ['++']
        ::= ['...'] '_'      |
            ['...']  refName |
              tupleArg       |
              string         |
              const          |
              number         ;

tupleArg Throw ['(' ')', '[', ']' T]
        ::= '(' [T] [argMany [T]] ')'| '[' [T] [argMany [T]] ']';

lambdef Throw ['{', '}', '|', ',', 'from', 'let', 'end', T]
        ::= '{' [T]
                ['|' [singleArgs [T]] '|']
                [T]
                [statements [T]]
            '}'
            |
            'from' [T]
                [singleArgs [T]]
            'let' [T]
                [statements [T]]
            'end'
            ;

atom  Throw ['++']
        ::=  refName | const | string ('++' string)* | number |
            '(' expr ')'|
             listCons | tupleCons | setCons | dictCons | compreh |
             lambdef;

trailer Throw ['!' '[' ']' '\'']
        ::= '!' '[' exprCons ']' | '\'' symbol;

atomExpr Throw[T]
        ::= atom ([T] trailer)*;


invExp  ::= atomExpr (atomExpr | invTrailer)*;

invTrailer Throw ['.']
        ::= '.' atomExpr;

unaryOp := 'not', '+', '-';
suffix  := '?', '??';
factor  ::= [unaryOp] invExp [suffix];


binExp ::= factor ((operator | 'or' | 'and' | 'in' | 'is' | 'is not' | 'not in') factor)*;

caseExp Throw ['case', 'end', T]
        ::= 'case' expr [T] asExp* 'end';

asExp  Throw ['=>', T, 'as', 'when']
        ::= ['as' argMany]
            [
              [T] 'when' [T] expr
            ]
            [T]
            ['=>' [T] [statements]];

testExpr ::= caseExp | binExp;

where Throw ['where', T, 'end']   ::= 'where' [T] [statements [T]] 'end';

expr    ::=  testExpr (thenTrailer | applicationTrailer)* [[T] where];

thenTrailer Throw ['then']
        ::= 'then' testExpr;

applicationTrailer Throw ['$']
        ::= '$' testExpr;

statements Throw [T]
        ::= statement ([T] statement)*;

statement
        ::= (label | let | expr | into | importExpr) [';'];

let    Throw ['=' '!']
        ::= ['let'] symbol trailer* '=' expr;

exprMany Throw [',', T] ::= expr [([T] ',' [T] expr)+];
unpack   Throw ['...']  ::= '...' expr;
exprCons Throw [',' T]    ::= exprMany ([T] ',' [T] unpack [[T] ',' [T] exprMany])* [','];

kv       Throw [':', T] ::= expr ':' expr;
kvMany   Throw [',', T] ::= kv [([T] ',' [T] kv)+  [T]];
kvCons   Throw [',' T]  ::= kvMany ([T] ',' [T] unpack [[T] ',' [T] kvMany])* [','];

listCons  Throw ['[' ']' T] ::= '[' [T] [exprCons [T]] ']';
tupleCons  Throw ['(' ')' T] ::= '(' [T] [exprCons [T]] ')';
setCons  Throw ['%' '{' '}' T] ::=  '%' '{' [T] [exprCons [T]] '}';
dictCons  Throw ['%' '{' '}' T] ::=  '%' '{' [T] [kvCons [T]] '}';
compreh  Throw['from' 'yield' T] ::=  'from' [T] exprMany [[T] 'not'] [T] 'yield' [T] lambdef;

label Throw ['@'] ::= '@' symbol;
into Throw ['into'] ::= 'into' symbol;

file Throw [T] ::= [T] [statements [T]];
