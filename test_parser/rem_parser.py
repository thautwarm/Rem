# This file is automatically generated by EBNFParser.
from Ruikowa.ObjectRegex.Tokenizer import unique_literal_cache_pool, regex_matcher, char_matcher, str_matcher, Tokenizer
from Ruikowa.ObjectRegex.Node import AstParser, Ref, SeqParser, LiteralValueParser, LiteralNameParser, Undef
namespace = globals()
recur_searcher = set()
token_table = ((unique_literal_cache_pool["newline"], regex_matcher('\n+')),
               (unique_literal_cache_pool["space"], regex_matcher('\s+')),
               (unique_literal_cache_pool["symbol"], regex_matcher('[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff_]{1}[a-zA-Z\u4e00-\u9fa5\u3040-\u309f\u30a0-\u30ff\d_]*')),
               (unique_literal_cache_pool["string"], regex_matcher('"([^\"]+|\.)*"')),
               (unique_literal_cache_pool["comments"], regex_matcher('(#.*)|(((/\*)+?[\w\W]+?(\*/)+))')),
               (unique_literal_cache_pool["number"], regex_matcher('0[Xx][\da-fA-F]+|\d+(?:\.\d+|)(?:E\-{0,1}\d+|)')),
               (unique_literal_cache_pool["operator"], str_matcher(('//', '--', '++', '**'))),
               (unique_literal_cache_pool["operator"], char_matcher(('/', '-', '+', '*', '%'))),
               (unique_literal_cache_pool["operator"], str_matcher(('||', '^^', '&&'))),
               (unique_literal_cache_pool["operator"], char_matcher(('|', '^', '&'))),
               (unique_literal_cache_pool["operator"], str_matcher(('|>', '>>', '<<'))),
               (unique_literal_cache_pool["operator"], char_matcher(('>', '<'))),
               (unique_literal_cache_pool["operator"], str_matcher(('>=', '==', '<=', '<-', '!='))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('import', 'from', 'as'))),
               (unique_literal_cache_pool["auto_const"], char_matcher((',', ')', '('))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('True', 'None', 'False'))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('&'))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('...'))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('_'))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('}', '|', '{', ']', '['))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('let', 'end', '++'))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('!'))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('\''))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('.'))),
               (unique_literal_cache_pool["unaryOp"], str_matcher(('not'))),
               (unique_literal_cache_pool["unaryOp"], char_matcher(('-', '+'))),
               (unique_literal_cache_pool["suffix"], char_matcher(('?'))),
               (unique_literal_cache_pool["suffix"], str_matcher(('??'))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('where', 'when', 'then', 'or', 'not in', 'is', 'is not', 'in', 'case', 'and', '=>'))),
               (unique_literal_cache_pool["auto_const"], char_matcher((';', '$'))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('='))),
               (unique_literal_cache_pool["auto_const"], char_matcher((':', '%'))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('yield', 'not'))),
               (unique_literal_cache_pool["auto_const"], char_matcher(('@'))),
               (unique_literal_cache_pool["auto_const"], str_matcher(('into'))),
               (unique_literal_cache_pool["keyword"], str_matcher(('yield', 'where', 'when', 'then', 'or', 'not', 'let', 'is', 'into', 'in', 'import', 'from', 'end', 'case', 'as', 'and', 'True', 'None', 'False'))))

class UNameEnum:
# names
    kv = unique_literal_cache_pool['kv']
    importAs = unique_literal_cache_pool['importAs']
    let = unique_literal_cache_pool['let']
    fromImportExpr = unique_literal_cache_pool['fromImportExpr']
    refName = unique_literal_cache_pool['refName']
    binExp = unique_literal_cache_pool['binExp']
    symbol = unique_literal_cache_pool['symbol']
    setCons = unique_literal_cache_pool['setCons']
    testExpr = unique_literal_cache_pool['testExpr']
    applicationTrailer = unique_literal_cache_pool['applicationTrailer']
    tupleArg = unique_literal_cache_pool['tupleArg']
    T = unique_literal_cache_pool['T']
    atomExpr = unique_literal_cache_pool['atomExpr']
    caseExp = unique_literal_cache_pool['caseExp']
    singleImportExpr = unique_literal_cache_pool['singleImportExpr']
    arg = unique_literal_cache_pool['arg']
    expr = unique_literal_cache_pool['expr']
    statement = unique_literal_cache_pool['statement']
    unpack = unique_literal_cache_pool['unpack']
    auto_const = unique_literal_cache_pool['auto_const']
    asExp = unique_literal_cache_pool['asExp']
    importExpr = unique_literal_cache_pool['importExpr']
    comments = unique_literal_cache_pool['comments']
    kvMany = unique_literal_cache_pool['kvMany']
    tupleCons = unique_literal_cache_pool['tupleCons']
    string = unique_literal_cache_pool['string']
    number = unique_literal_cache_pool['number']
    singleArgs = unique_literal_cache_pool['singleArgs']
    statements = unique_literal_cache_pool['statements']
    lambdef = unique_literal_cache_pool['lambdef']
    exprMany = unique_literal_cache_pool['exprMany']
    dictCons = unique_literal_cache_pool['dictCons']
    suffix = unique_literal_cache_pool['suffix']
    space = unique_literal_cache_pool['space']
    kvCons = unique_literal_cache_pool['kvCons']
    into = unique_literal_cache_pool['into']
    compreh = unique_literal_cache_pool['compreh']
    atom = unique_literal_cache_pool['atom']
    label = unique_literal_cache_pool['label']
    operator = unique_literal_cache_pool['operator']
    factor = unique_literal_cache_pool['factor']
    where = unique_literal_cache_pool['where']
    unaryOp = unique_literal_cache_pool['unaryOp']
    iterMark = unique_literal_cache_pool['iterMark']
    exprCons = unique_literal_cache_pool['exprCons']
    invExp = unique_literal_cache_pool['invExp']
    invTrailer = unique_literal_cache_pool['invTrailer']
    trailer = unique_literal_cache_pool['trailer']
    listCons = unique_literal_cache_pool['listCons']
    keyword = unique_literal_cache_pool['keyword']
    thenTrailer = unique_literal_cache_pool['thenTrailer']
    argMany = unique_literal_cache_pool['argMany']
    remImport = unique_literal_cache_pool['remImport']
    file = unique_literal_cache_pool['file']
    newline = unique_literal_cache_pool['newline']
    const = unique_literal_cache_pool['const']
# values
    auto_const_where = unique_literal_cache_pool['where']
    auto_const_and = unique_literal_cache_pool['and']
    auto_const_True = unique_literal_cache_pool['True']
    auto_const_in = unique_literal_cache_pool['in']
    keyword_False = unique_literal_cache_pool['False']
    keyword_where = unique_literal_cache_pool['where']
    keyword_into = unique_literal_cache_pool['into']
    auto_const_or = unique_literal_cache_pool['or']
    auto_const_case = unique_literal_cache_pool['case']
    auto_const_then = unique_literal_cache_pool['then']
    keyword_when = unique_literal_cache_pool['when']
    keyword_then = unique_literal_cache_pool['then']
    auto_const_end = unique_literal_cache_pool['end']
    keyword_is = unique_literal_cache_pool['is']
    auto_const_when = unique_literal_cache_pool['when']
    auto_const_False = unique_literal_cache_pool['False']
    auto_const_as = unique_literal_cache_pool['as']
    keyword_True = unique_literal_cache_pool['True']
    auto_const_not = unique_literal_cache_pool['not']
    auto_const_into = unique_literal_cache_pool['into']
    keyword_from = unique_literal_cache_pool['from']
    keyword_let = unique_literal_cache_pool['let']
    auto_const_yield = unique_literal_cache_pool['yield']
    auto_const__ = unique_literal_cache_pool['_']
    keyword_yield = unique_literal_cache_pool['yield']
    unaryOp_not = unique_literal_cache_pool['not']
    auto_const_import = unique_literal_cache_pool['import']
    keyword_not = unique_literal_cache_pool['not']
    auto_const_let = unique_literal_cache_pool['let']
    auto_const_from = unique_literal_cache_pool['from']
    auto_const_None = unique_literal_cache_pool['None']
    auto_const_is = unique_literal_cache_pool['is']
    keyword_end = unique_literal_cache_pool['end']
    keyword_as = unique_literal_cache_pool['as']
    keyword_None = unique_literal_cache_pool['None']
    keyword_import = unique_literal_cache_pool['import']
    keyword_case = unique_literal_cache_pool['case']
    keyword_or = unique_literal_cache_pool['or']
    keyword_and = unique_literal_cache_pool['and']
    keyword_in = unique_literal_cache_pool['in']
        
token_func = lambda _: Tokenizer.from_raw_strings(_, token_table, ({"space", "comments"}, {}))
newline = LiteralNameParser('newline')
space = LiteralNameParser('space')
symbol = LiteralNameParser('symbol')
string = LiteralNameParser('string')
comments = LiteralNameParser('comments')
number = LiteralNameParser('number')
operator = LiteralNameParser('operator')
unaryOp = LiteralNameParser('unaryOp')
suffix = LiteralNameParser('suffix')
keyword = LiteralNameParser('keyword')
T = AstParser([SeqParser([Ref('newline')], at_least=1,at_most=Undef)],
              name="T",
              to_ignore=({}, {}))
importAs = AstParser([Ref('symbol'), SeqParser(['as', Ref('symbol')], at_least=0,at_most=1)],
                     name="importAs",
                     to_ignore=({}, {}))
fromImportExpr = AstParser(['from', Ref('singleArgs'), 'import', '(', Ref('importAs'), SeqParser([',', Ref('importAs')], at_least=0,at_most=Undef), ')'],
                           name="fromImportExpr",
                           to_ignore=({}, {}))
importExpr = AstParser([Ref('singleImportExpr')],
                       [Ref('fromImportExpr')],
                       [Ref('remImport')],
                       name="importExpr",
                       to_ignore=({}, {}))
singleImportExpr = AstParser(['import', Ref('singleArgs'), SeqParser(['as', Ref('symbol')], at_least=0,at_most=1)],
                             name="singleImportExpr",
                             to_ignore=({}, {}))
remImport = AstParser(['import', Ref('string'), SeqParser(['as', Ref('symbol')], at_least=0,at_most=1)],
                      name="remImport",
                      to_ignore=({}, {'import', 'as'}))
const = AstParser(['True'],
                  ['False'],
                  ['None'],
                  name="const",
                  to_ignore=({}, {}))
refName = AstParser([SeqParser(['&'], at_least=0,at_most=1), Ref('symbol')],
                    name="refName",
                    to_ignore=({}, {}))
singleArgs = AstParser([Ref('symbol'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('symbol')], at_least=0,at_most=Undef)],
                       name="singleArgs",
                       to_ignore=({"T"}, {','}))
argMany = AstParser([Ref('arg'), SeqParser([SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('arg')], at_least=1,at_most=Undef), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), SeqParser([Ref('iterMark')], at_least=0,at_most=1)],
                    name="argMany",
                    to_ignore=({"T"}, {','}))
iterMark = AstParser([','],
                     name="iterMark",
                     to_ignore=({}, {}))
arg = AstParser([SeqParser(['...'], at_least=0,at_most=1), '_'],
                [SeqParser(['...'], at_least=0,at_most=1), Ref('refName')],
                [Ref('tupleArg')],
                [Ref('string')],
                [Ref('const')],
                [Ref('number')],
                name="arg",
                to_ignore=({}, {'++'}))
tupleArg = AstParser(['(', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('argMany'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), ')'],
                     ['[', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('argMany'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), ']'],
                     name="tupleArg",
                     to_ignore=({"T"}, {'(', ')', '[', ']'}))
lambdef = AstParser(['{', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser(['|', SeqParser([Ref('singleArgs'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), '|'], at_least=0,at_most=1), SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('statements'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), '}'],
                    ['from', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('singleArgs'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), 'let', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('statements'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), 'end'],
                    name="lambdef",
                    to_ignore=({"T"}, {'{', '}', '|', ',', 'from', 'let', 'end'}))
atom = AstParser([Ref('refName')],
                 [Ref('const')],
                 [Ref('string'), SeqParser(['++', Ref('string')], at_least=0,at_most=Undef)],
                 [Ref('number')],
                 ['(', Ref('expr'), ')'],
                 [Ref('listCons')],
                 [Ref('tupleCons')],
                 [Ref('setCons')],
                 [Ref('dictCons')],
                 [Ref('compreh')],
                 [Ref('lambdef')],
                 name="atom",
                 to_ignore=({}, {'++'}))
trailer = AstParser(['!', '[', Ref('exprCons'), ']'],
                    ['\'', Ref('symbol')],
                    name="trailer",
                    to_ignore=({}, {'!', '[', ']', '\''}))
atomExpr = AstParser([Ref('atom'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), Ref('trailer')], at_least=0,at_most=Undef)],
                     name="atomExpr",
                     to_ignore=({"T"}, {}))
invExp = AstParser([Ref('atomExpr'), SeqParser([Ref('atomExpr')], [Ref('invTrailer')], at_least=0,at_most=Undef)],
                   name="invExp",
                   to_ignore=({}, {}))
invTrailer = AstParser(['.', Ref('atomExpr')],
                       name="invTrailer",
                       to_ignore=({}, {'.'}))
factor = AstParser([SeqParser([Ref('unaryOp')], at_least=0,at_most=1), Ref('invExp'), SeqParser([Ref('suffix')], at_least=0,at_most=1)],
                   name="factor",
                   to_ignore=({}, {}))
binExp = AstParser([Ref('factor'), SeqParser([SeqParser([Ref('operator')], ['or'], ['and'], ['in'], ['is'], ['is not'], ['not in'], at_least=1,at_most=1), Ref('factor')], at_least=0,at_most=Undef)],
                   name="binExp",
                   to_ignore=({}, {}))
caseExp = AstParser(['case', Ref('expr'), SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('asExp')], at_least=0,at_most=Undef), 'end'],
                    name="caseExp",
                    to_ignore=({"T"}, {'case', 'end'}))
asExp = AstParser([SeqParser(['as', Ref('argMany')], at_least=0,at_most=1), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), 'when', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('expr')], at_least=0,at_most=1), SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser(['=>', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('statements')], at_least=0,at_most=1)], at_least=0,at_most=1)],
                  name="asExp",
                  to_ignore=({"T"}, {'=>', 'as', 'when'}))
testExpr = AstParser([Ref('caseExp')],
                     [Ref('binExp')],
                     name="testExpr",
                     to_ignore=({}, {}))
where = AstParser(['where', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('statements'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), 'end'],
                  name="where",
                  to_ignore=({"T"}, {'where', 'end'}))
expr = AstParser([Ref('testExpr'), SeqParser([Ref('thenTrailer')], [Ref('applicationTrailer')], at_least=0,at_most=Undef), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), Ref('where')], at_least=0,at_most=1)],
                 name="expr",
                 to_ignore=({}, {}))
thenTrailer = AstParser(['then', Ref('testExpr')],
                        name="thenTrailer",
                        to_ignore=({}, {'then'}))
applicationTrailer = AstParser(['$', Ref('testExpr')],
                               name="applicationTrailer",
                               to_ignore=({}, {'$'}))
statements = AstParser([Ref('statement'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), Ref('statement')], at_least=0,at_most=Undef)],
                       name="statements",
                       to_ignore=({"T"}, {}))
statement = AstParser([SeqParser([Ref('label')], [Ref('let')], [Ref('expr')], [Ref('into')], [Ref('importExpr')], at_least=1,at_most=1), SeqParser([';'], at_least=0,at_most=1)],
                      name="statement",
                      to_ignore=({}, {}))
let = AstParser([SeqParser(['let'], at_least=0,at_most=1), Ref('symbol'), SeqParser([Ref('trailer')], at_least=0,at_most=Undef), '=', Ref('expr')],
                name="let",
                to_ignore=({}, {'=', '!'}))
exprMany = AstParser([Ref('expr'), SeqParser([SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('expr')], at_least=1,at_most=Undef)], at_least=0,at_most=1)],
                     name="exprMany",
                     to_ignore=({"T"}, {','}))
unpack = AstParser(['...', Ref('expr')],
                   name="unpack",
                   to_ignore=({}, {'...'}))
exprCons = AstParser([Ref('exprMany'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('unpack'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('exprMany')], at_least=0,at_most=1)], at_least=0,at_most=Undef), SeqParser([','], at_least=0,at_most=1)],
                     name="exprCons",
                     to_ignore=({"T"}, {','}))
kv = AstParser([Ref('expr'), ':', Ref('expr')],
               name="kv",
               to_ignore=({"T"}, {':'}))
kvMany = AstParser([Ref('kv'), SeqParser([SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('kv')], at_least=1,at_most=Undef), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1)],
                   name="kvMany",
                   to_ignore=({"T"}, {','}))
kvCons = AstParser([Ref('kvMany'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('unpack'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), ',', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('kvMany')], at_least=0,at_most=1)], at_least=0,at_most=Undef), SeqParser([','], at_least=0,at_most=1)],
                   name="kvCons",
                   to_ignore=({"T"}, {','}))
listCons = AstParser(['[', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('exprCons'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), ']'],
                     name="listCons",
                     to_ignore=({"T"}, {'[', ']'}))
tupleCons = AstParser(['(', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('exprCons'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), ')'],
                      name="tupleCons",
                      to_ignore=({"T"}, {'(', ')'}))
setCons = AstParser(['%', '{', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('exprCons'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), '}'],
                    name="setCons",
                    to_ignore=({"T"}, {'%', '{', '}'}))
dictCons = AstParser(['%', '{', SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('kvCons'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1), '}'],
                     name="dictCons",
                     to_ignore=({"T"}, {'%', '{', '}'}))
compreh = AstParser(['from', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('exprMany'), SeqParser([SeqParser([Ref('T')], at_least=0,at_most=1), 'not'], at_least=0,at_most=1), SeqParser([Ref('T')], at_least=0,at_most=1), 'yield', SeqParser([Ref('T')], at_least=0,at_most=1), Ref('lambdef')],
                    name="compreh",
                    to_ignore=({"T"}, {'from', 'yield'}))
label = AstParser(['@', Ref('symbol')],
                  name="label",
                  to_ignore=({}, {'@'}))
into = AstParser(['into', Ref('symbol')],
                 name="into",
                 to_ignore=({}, {'into'}))
file = AstParser([SeqParser([Ref('T')], at_least=0,at_most=1), SeqParser([Ref('statements'), SeqParser([Ref('T')], at_least=0,at_most=1)], at_least=0,at_most=1)],
                 name="file",
                 to_ignore=({"T"}, {}))
file.compile(namespace, recur_searcher)